package main

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base32"
	"encoding/binary"
	"fmt"
	"golang.org/x/xerrors"
	"math"
	"os"
	"time"
)

var initialCountTimeStep int64 = 0
var timeStep int64 = 30 // in sec
var otpDigitValue = 6
var encodedSecret = "CUBUZ3LGDQETIKD7" // example secret, already reset

// https://tools.ietf.org/html/rfc6238
// The keys MAY be stored in a tamper-resistant device and SHOULD be
// protected against unauthorized access and usage.

func main() {
	secretKey, err := base32.StdEncoding.DecodeString(encodedSecret)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed decoding secret: %v", err)
	}

	var otpInString string
	if otp, err := totp(secretKey, initialCountTimeStep, timeStep); err != nil {
		fmt.Fprintf(os.Stderr, err.Error())
	} else {
		otpInString = fmt.Sprint(otp)
	}

	if len(otpInString) == 5 {
		fmt.Println("0" + otpInString)
	} else {
		fmt.Println(otpInString)
	}
}

// golang timestamp support int64 so that post-2038 timestamp will be supported
// https://tools.ietf.org/html/rfc6238#section-4.2
func totp(k []byte, t0, x int64) (uint32, error) {
	numberOfTimeSteps := deriveNumberOfCurrentTimeStep(t0, x)
	counter := make([]byte, 8)

	// The Key (K), the Counter (C), and Data values are hashed high-order byte first. https://tools.ietf.org/html/rfc4226#section-5.2
	binary.BigEndian.PutUint64(counter, uint64(numberOfTimeSteps))
	if hotpValue, error := hotp(k, counter); error != nil {
		return 0, error
	} else {
		return hotpValue, nil
	}
}

// https://tools.ietf.org/html/rfc4226#section-5.2
func hotp(key, counter []byte) (uint32, error) {
	if hmacValue, err := hmacSha1(key, counter); err != nil {
		return 0, err
	} else if dynamicTruncation, err := truncate(hmacValue); err != nil {
		return 0, err
	} else {
		return dynamicTruncation % uint32(math.Pow10(otpDigitValue)), nil
	}
}

func hmacSha1(key []byte, counter []byte) ([]byte, error) {
	// counter is 8-byte as defined in https://tools.ietf.org/html/rfc4226#section-5.1
	if len(counter) != 8 {
		return nil, xerrors.New(fmt.Sprintf("counter is not 8 byte: %v", counter))
	}

	hm := hmac.New(sha1.New, key)
	if _, err := hm.Write(counter); err != nil {
		return nil, err
	}

	return hm.Sum(nil), nil
}

// https://tools.ietf.org/html/rfc4226#section-5.3
func truncate(hmacSha1 []byte) (uint32, error) {
	// hmacSha1 needs to be 20 byte (160 bit) length
	if len(hmacSha1) != 20 {
		return 0, xerrors.New(fmt.Sprintf("hash does not seem to be hmac-sha-1 because it's length isn't 20 byte: %v", len(hmacSha1)))
	}

	// the low-order 4 bits of
	offsetBits := hmacSha1[19] & 0xF
	offset := int(offsetBits)
	p := hmacSha1[offset : offset+4]

	// The HOTP values generated by the HOTP generator are treated as big endian.
	// https://tools.ietf.org/html/rfc4226#section-5.2
	// Return the Last 31 bits of P
	return binary.BigEndian.Uint32(p) & 0x7FFFFFFF, nil
}

func deriveNumberOfCurrentTimeStep(t0, x int64) int64 {
	return (time.Now().Unix() - t0) / x
}
