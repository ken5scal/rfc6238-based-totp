package totp_client

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base32"
	"encoding/binary"
	"fmt"
	"golang.org/x/xerrors"
	"math"
	"time"
)

type credential struct {
	otpDigitValue        int // represents digit number shown in totp client. mostly 6
	secret               string
	timeStep             int64 // frequency the value changed in sec. mostly 30 sec
	initialCountTimeStep int64
}

func NewCredential(secret string) credential {
	return credential{
		otpDigitValue:        6,
		initialCountTimeStep: 0,
		timeStep:             30,
		secret:               secret,
	}
}

// golang timestamp support int64 so that post-2038 timestamp will be supported
// https://tools.ietf.org/html/rfc6238#section-4.2
func (c credential) GetTOTP() (string, error) {
	secretKey, err := base32.StdEncoding.DecodeString(c.secret)
	if err != nil {
		return "", xerrors.Errorf("failed decoding secret: %v", err)
	}

	var otpInString string
	if otp, err := totp(secretKey, c.initialCountTimeStep, c.timeStep, c.otpDigitValue); err != nil {
		return "", xerrors.Errorf("failed reading totp: %v", err)
	} else {
		otpInString = fmt.Sprint(otp)
	}

	if len(otpInString) == 5 {
		otpInString = "0" + otpInString
	}

	return otpInString, nil
}

// golang timestamp support int64 so that post-2038 timestamp will be supported
// https://tools.ietf.org/html/rfc6238#section-4.2
func totp(k []byte, t0, x int64, digitValue int) (uint32, error) {
	numberOfTimeSteps := deriveNumberOfCurrentTimeStep(t0, x)
	counter := make([]byte, 8)

	// The Key (K), the Counter (C), and Data values are hashed high-order byte first. https://tools.ietf.org/html/rfc4226#section-5.2
	binary.BigEndian.PutUint64(counter, uint64(numberOfTimeSteps))
	if hotpValue, error := hotp(k, counter, digitValue); error != nil {
		return 0, error
	} else {
		return hotpValue, nil
	}
}

// https://tools.ietf.org/html/rfc4226#section-5.2
func hotp(key, counter []byte, otpDigitValue int) (uint32, error) {
	if hmacValue, err := hmacSha1(key, counter); err != nil {
		return 0, err
	} else if dynamicTruncation, err := truncate(hmacValue); err != nil {
		return 0, err
	} else {
		return dynamicTruncation % uint32(math.Pow10(otpDigitValue)), nil
	}
}

func hmacSha1(key []byte, counter []byte) ([]byte, error) {
	// counter is 8-byte as defined in https://tools.ietf.org/html/rfc4226#section-5.1
	if len(counter) != 8 {
		return nil, xerrors.New(fmt.Sprintf("counter is not 8 byte: %v", counter))
	}

	hm := hmac.New(sha1.New, key)
	if _, err := hm.Write(counter); err != nil {
		return nil, err
	}

	return hm.Sum(nil), nil
}

// https://tools.ietf.org/html/rfc4226#section-5.3
func truncate(hmacSha1 []byte) (uint32, error) {
	// hmacSha1 needs to be 20 byte (160 bit) length
	if len(hmacSha1) != 20 {
		return 0, xerrors.New(fmt.Sprintf("hash does not seem to be hmac-sha-1 because it's length isn't 20 byte: %v", len(hmacSha1)))
	}

	// the low-order 4 bits of
	offsetBits := hmacSha1[19] & 0xF
	offset := int(offsetBits)
	p := hmacSha1[offset : offset+4]

	// The HOTP values generated by the HOTP generator are treated as big endian.
	// https://tools.ietf.org/html/rfc4226#section-5.2
	// Return the Last 31 bits of P
	return binary.BigEndian.Uint32(p) & 0x7FFFFFFF, nil
}

func deriveNumberOfCurrentTimeStep(t0, x int64) int64 {
	return (time.Now().Unix() - t0) / x
}
